<conversation_summary>
<decisions>

1.  A separate public.profiles table will not be created; the flashcards table will link directly to auth.users.
2.  When a user account is deleted, a trigger will call a function to delete all associated flashcards.
3.  The flashcards table will include nullable columns for a future FSRS implementation (due, stability, difficulty, lapses, state).
4.  The FSRS state column will be a custom ENUM type.
5.  The primary key for the flashcards table will be a BIGINT.
6.  An index on flashcards(user_id) is required for efficient lookups.
7.  ORDER BY random() is acceptable for random card selection in the MVP.
8.  Row-Level Security (RLS) policies will be implemented to ensure users can only access their own data.
9.  The original source text for flashcard generation will not be stored.
10. created_at and updated_at timestamps are not needed for the flashcards table.
11. NOT NULL constraints are sufficient for question and answer columns; no length checks are needed.
12. No special index for FSRS queries is needed for the MVP.
13. Pagination will be handled with a simple OFFSET/LIMIT approach.
14. All new database objects will be in the public schema.
15. Agreed-upon names are flashcards (table), flashcard_state (enum), and handle_user_deletion (function).
16. The foreign key to auth.users will include ON UPDATE CASCADE.
17. Descriptive comments will be added to the database schema.
    </decisions>

<matched_recommendations>

1.  User Deletion: Use a trigger that calls a security-definer function to delete a user's data from public.flashcards when they are deleted from auth.users.
2.  Foreign Key: The flashcards table must have a user_id column of type UUID with a foreign key referencing auth.users(id) and including ON UPDATE CASCADE.
3.  FSRS Columns & Defaults: Add nullable columns for FSRS: due (TIMESTAMPTZ, default now()), stability (REAL, default 0), difficulty (REAL, default 0), lapses (INTEGER, default 0), and state (ENUM, default 'new').
4.  FSRS State ENUM: Create a custom PostgreSQL ENUM type named flashcard_state with values: 'new', 'learning', 'review', and 'relearning'.
5.  Primary Key: Use BIGINT GENERATED BY DEFAULT AS IDENTITY for the flashcards primary key.
6.  Indexing: Create an index on the flashcards(user_id) column to ensure fast retrieval of a user's card collection.
7.  Data Integrity: The question and answer columns should have a NOT NULL constraint.
8.  Row-Level Security: Enable RLS on the flashcards table with a policy of USING (auth.uid() = user_id) for all actions.
9.  Schema and Naming: All objects will be in the public schema with the agreed-upon names (flashcards, flashcard_state, handle_user_deletion).
10. Documentation: Add comments to the table and columns using COMMENT ON to serve as inline documentation.
    </matched_recommendations>

<database_planning_summary>
This summary outlines the database plan for the AI Flashcard Generator MVP. The core of the schema is a single table, public.flashcards, which will store all user-generated flashcards.

Main Requirements & Entities:

- The primary entity is the flashcard, which belongs to a user.
- The flashcards table will contain columns for the question and answer (both TEXT NOT NULL).
- To support a future Free Spaced Repetition Scheduler (FSRS), the table will also include fields for due, stability, difficulty, lapses, and state, with appropriate defaults for newly created cards.
- The state will be managed by a custom ENUM type named flashcard_state.

Relationships:

- A one-to-many relationship exists between users and flashcards.
- This will be implemented by a user_id (UUID) column in the flashcards table, which acts as a foreign key referencing the id column in Supabase's auth.users table.

Security & Scalability:

- Security: Data privacy is paramount and will be enforced using PostgreSQL's Row-Level Security (RLS). A policy on the flashcards table will ensure that users can only view and manipulate their own cards.
- User Deletion: To handle data cleanup when a user deletes their account, a trigger will be set up to execute a function (handle_user_deletion) that removes all of the user's corresponding flashcards.
- Scalability: For the MVP, performance will be addressed by an index on the user_id column for fast lookups. Pagination for infinite scroll will be handled with a simple OFFSET/LIMIT query. More advanced indexing (for FSRS)
  and pagination strategies were considered but deferred to future versions to keep the MVP simple.

The schema is designed to be simple and focused for the MVP, while including the necessary hooks for future feature development like the FSRS implementation.
</database_planning_summary>

<unresolved_issues>
There are no unresolved issues. All initial ambiguities have been clarified, and there is a clear plan for the MVP database schema.
</unresolved_issues>
</conversation_summary>
