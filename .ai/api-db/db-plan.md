# Database Schema Plan

This document outlines the PostgreSQL database schema for the AI Flashcard Generator. The design is based on the project's PRD, tech stack, and decisions from the database planning session.

### 1. Tables and Data Types

#### Custom Types

First, we define a custom `ENUM` type to represent the different states a flashcard can be in, primarily for the future FSRS (Free Spaced Repetition Scheduler) implementation.

```sql
-- public.flashcard_state ENUM
-- Defines the possible states for a flashcard in the FSRS learning cycle.
CREATE TYPE public.flashcard_state AS ENUM (
  'new',       -- The card has been created but not yet studied.
  'learning',  -- The card is currently in the initial learning phase.
  'review',    -- The card has graduated from the learning phase and is now in review.
  'relearning' -- The card was forgotten and is being learned again.
);
```

#### Tables

The core of the database is a single table, `public.flashcards`, which stores all user-generated cards.

```sql
-- public.flashcards table
-- Stores user-generated flashcards and their associated FSRS metadata.
CREATE TABLE public.flashcards (
  -- Core Columns
  id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  user_id UUID NOT NULL REFERENCES auth.users(id) ON UPDATE CASCADE,
  question TEXT NOT NULL,
  answer TEXT NOT NULL,

  -- FSRS (Free Spaced Repetition Scheduler) Columns
  -- These are nullable and have defaults to support progressive feature implementation.
  due TIMESTAMPTZ DEFAULT now() NULL,
  stability REAL DEFAULT 0 NULL,
  difficulty REAL DEFAULT 0 NULL,
  lapses INTEGER DEFAULT 0 NULL,
  state public.flashcard_state DEFAULT 'new' NULL
);

-- Add comments for clarity
COMMENT ON TABLE public.flashcards IS 'Stores user-generated flashcards and their associated FSRS metadata.';
COMMENT ON COLUMN public.flashcards.id IS 'The unique identifier for each flashcard.';
COMMENT ON COLUMN public.flashcards.user_id IS 'Foreign key referencing the user who owns the card.';
COMMENT ON COLUMN public.flashcards.question IS 'The front side of the flashcard.';
COMMENT ON COLUMN public.flashcards.answer IS 'The back side of the flashcard.';
COMMENT ON COLUMN public.flashcards.due IS 'The timestamp when the card is next due for review.';
COMMENT ON COLUMN public.flashcards.stability IS 'A measure of how well the memory of the card is established.';
COMMENT ON COLUMN public.flashcards.difficulty IS 'A measure of how difficult the card is to remember.';
COMMENT ON COLUMN public.flashcards.lapses IS 'The number of times the user has forgotten the card after graduating it.';
COMMENT ON COLUMN public.flashcards.state IS 'The current FSRS state of the card (new, learning, review, relearning).';
```

### 2. Relationships

- **`auth.users` to `public.flashcards`**: A **one-to-many** relationship.
  - One user can have many flashcards.
  - This is implemented via the `flashcards.user_id` foreign key, which references `auth.users(id)`.
  - The `ON UPDATE CASCADE` clause ensures that if a user's `id` in `auth.users` changes, the `user_id` in `flashcards` is updated automatically.
  - Data deletion is handled by a separate trigger (see Section 4) to ensure all of a user's flashcards are removed when their account is deleted.

### 3. Indexes

To ensure efficient querying, especially for fetching all cards belonging to a specific user, the following index is created:

- **Index on `user_id`**: Improves the performance of lookups based on the user.

```sql
-- Index for user_id
-- Speeds up queries that filter flashcards by user.
CREATE INDEX ix_flashcards_user_id ON public.flashcards(user_id);
```

### 4. PostgreSQL Policies and Triggers

#### Row-Level Security (RLS)

To ensure data privacy, Row-Level Security (RLS) is enabled on the `flashcards` table. The policy ensures that users can only interact with their own data.

```sql
-- Enable RLS on the flashcards table
ALTER TABLE public.flashcards ENABLE ROW LEVEL SECURITY;

-- Policy: Users can only access their own flashcards
-- This policy applies to all commands (SELECT, INSERT, UPDATE, DELETE).
CREATE POLICY "Users can manage their own flashcards"
ON public.flashcards
FOR ALL
USING (auth.uid() = user_id);
```

#### User Deletion Trigger

To maintain data integrity and fulfill the requirement to delete all of a user's data upon account deletion, a trigger is set up. This trigger calls a function that removes the user's flashcards when their corresponding entry in `auth.users` is deleted.

```sql
-- Function to delete a user's flashcards
-- This function is called by a trigger when a user is deleted from auth.users.
CREATE OR REPLACE FUNCTION public.handle_user_deletion()
RETURNS TRIGGER
LANGUAGE plpgsql
SECURITY DEFINER SET search_path = public
AS $$
BEGIN
  DELETE FROM public.flashcards WHERE user_id = OLD.id;
  RETURN OLD;
END;
$$;

-- Trigger to handle user deletion
-- Executes the function after a user is deleted from the auth.users table.
CREATE TRIGGER on_auth_user_deleted
  AFTER DELETE ON auth.users
  FOR EACH ROW
  EXECUTE FUNCTION public.handle_user_deletion();
```

### 5. Additional Notes

- **FSRS Columns**: The columns `due`, `stability`, `difficulty`, `lapses`, and `state` are included to support a future implementation of a Free Spaced Repetition Scheduler (FSRS). They are nullable and have sensible defaults so that the MVP can function without implementing the FSRS logic.
- **No `created_at`/`updated_at`**: Timestamps for creation and updates were deemed unnecessary for the MVP requirements.
- **No Source Text Storage**: The original source text used to generate flashcards will not be stored in the database.
- **Random Card Selection**: For the study module, random card selection will be handled with `ORDER BY random()` in the SQL query, which is sufficient for the MVP.
