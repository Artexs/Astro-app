import { useState, useEffect } from "react";

// DTO for a card generated by the AI, received from the Create page
interface GeneratedFlashcardDto {
  question: string;
  answer: string;
}

// Command model for the request payload to POST /api/flashcards
interface CreateFlashcardCommand {
  question: string;
  answer: string;
}

// Represents the complete state for the ReviewView
interface ReviewViewModel {
  cardsToReview: GeneratedFlashcardDto[];
  acceptedCount: number;
  isSaving: Record<string, boolean>; // Tracks saving state per card
}

export const useReviewView = () => {
  const [state, setState] = useState<ReviewViewModel>({
    cardsToReview: [],
    acceptedCount: 0,
    isSaving: {},
  });

  useEffect(() => {
    try {
      const generatedFlashcards = sessionStorage.getItem("generatedFlashcards");
      if (generatedFlashcards) {
        const cards = JSON.parse(generatedFlashcards);
        setState((prevState) => ({ ...prevState, cardsToReview: cards }));
        sessionStorage.removeItem("generatedFlashcards");
      } else {
        window.location.href = "/create";
      }
    } catch (error) {
      console.error("Failed to parse flashcards from sessionStorage", error);
      window.location.href = "/create";
    }
  }, []);

  const handleAccept = async (card: GeneratedFlashcardDto) => {
    const cardIdentifier = card.question;
    setState((prevState) => ({
      ...prevState,
      isSaving: { ...prevState.isSaving, [cardIdentifier]: true },
    }));

    try {
      const response = await fetch("/api/flashcards", {
        method: "POST",
        headers: {
          "Content-Type": "application/json",
        },
        body: JSON.stringify({
          question: card.question,
          answer: card.answer,
        } as CreateFlashcardCommand),
      });

      if (!response.ok) {
        throw new Error("Failed to save flashcard");
      }

      setState((prevState) => ({
        ...prevState,
        cardsToReview: prevState.cardsToReview.filter((c) => c.question !== card.question),
        acceptedCount: prevState.acceptedCount + 1,
        isSaving: { ...prevState.isSaving, [cardIdentifier]: false },
      }));
    } catch {
      setState((prevState) => ({
        ...prevState,
        isSaving: { ...prevState.isSaving, [cardIdentifier]: false },
      }));
    }
  };

  const handleReject = (card: GeneratedFlashcardDto) => {
    setState((prevState) => ({
      ...prevState,
      cardsToReview: prevState.cardsToReview.filter((c) => c.question !== card.question),
    }));
  };

  return {
    state,
    handleAccept,
    handleReject,
  };
};
