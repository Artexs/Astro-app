-- migration: create_flashcards_schema
-- description: this migration creates the initial database schema for the flashcards application, including the flashcards table, related types, indexes, row-level security policies, and a trigger for handling user deletion.
-- created_at: 2025-10-14 12:00:00 utc

-- step 1: define a custom enum type for flashcard state
-- this type represents the different states a flashcard can be in within the free spaced repetition scheduler (fsrs) logic.
create type public.flashcard_state as enum (
  '''new''',       -- the card has been created but not yet studied.
  '''learning''',  -- the card is currently in the initial learning phase.
  '''review''',    -- the card has graduated from the learning phase and is now in review.
  '''relearning''' -- the card was forgotten and is being learned again.
);

-- step 2: create the flashcards table
-- this table stores user-generated flashcards and their associated fsrs metadata.
create table public.flashcards (
  -- core columns
  id bigint generated by default as identity primary key,
  user_id uuid not null references auth.users(id) on update cascade,
  question text not null,
  answer text not null,

  -- fsrs (free spaced repetition scheduler) columns
  -- these are nullable and have defaults to support progressive feature implementation.
  due timestamptz default now() null,
  stability real default 0 null,
  difficulty real default 0 null,
  lapses integer default 0 null,
  state public.flashcard_state default '''new''' null
);

-- step 3: add comments to the table and columns for clarity
comment on table public.flashcards is '''stores user-generated flashcards and their associated fsrs metadata.''';
comment on column public.flashcards.id is '''the unique identifier for each flashcard.''';
comment on column public.flashcards.user_id is '''foreign key referencing the user who owns the card.''';
comment on column public.flashcards.question is '''the front side of the flashcard.''';
comment on column public.flashcards.answer is '''the back side of the flashcard.''';
comment on column public.flashcards.due is '''the timestamp when the card is next due for review.''';
comment on column public.flashcards.stability is '''a measure of how well the memory of the card is established.''';
comment on column public.flashcards.difficulty is '''a measure of how difficult the card is to remember.''';
comment on column public.flashcards.lapses is '''the number of times the user has forgotten the card after graduating it.''';
comment on column public.flashcards.state is '''the current fsrs state of the card (new, learning, review, relearning).''';

-- step 4: create an index on the user_id column
-- this index improves the performance of queries that filter flashcards by user.
create index ix_flashcards_user_id on public.flashcards(user_id);

-- step 5: enable row-level security (rls) on the flashcards table
-- rls is enabled to ensure that users can only access their own data.
alter table public.flashcards enable row level security;

-- step 6: create row-level security policies
-- these policies ensure that users can only manage their own flashcards.

-- policy: allow authenticated users to select their own flashcards
-- enables authenticated users to retrieve their own flashcards.
create policy "allow authenticated select access"
on public.flashcards
for select
to authenticated
using (auth.uid() = user_id);

-- policy: allow authenticated users to insert their own flashcards
-- enables authenticated users to create new flashcards for themselves.
create policy "allow authenticated insert access"
on public.flashcards
for insert
to authenticated
with check (auth.uid() = user_id);

-- policy: allow authenticated users to update their own flashcards
-- enables authenticated users to modify their own flashcards.
create policy "allow authenticated update access"
on public.flashcards
for update
to authenticated
using (auth.uid() = user_id)
with check (auth.uid() = user_id);

-- policy: allow authenticated users to delete their own flashcards
-- enables authenticated users to delete their own flashcards.
create policy "allow authenticated delete access"
on public.flashcards
for delete
to authenticated
using (auth.uid() = user_id);

-- step 7: create a function to handle user deletion
-- this function is triggered when a user is deleted from auth.users and removes all their associated flashcards.
create or replace function public.handle_user_deletion()
returns trigger
language plpgsql
security definer set search_path = public
as $$
begin
  delete from public.flashcards where user_id = old.id;
  return old;
end;
$$;

-- step 8: create a trigger to execute the user deletion function
-- this trigger fires after a user is deleted from the auth.users table.
create trigger on_auth_user_deleted
  after delete on auth.users
  for each row
  execute function public.handle_user_deletion();
